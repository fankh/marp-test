# Python 시큐어코딩 강의 스크립트

> 본 문서는 `Python_시큐어코딩_slides.md` 슬라이드에 대한 강사용 스크립트입니다.
> 각 슬라이드별로 강의 시 설명할 내용을 정리했습니다.

---

## 프로젝트 일정

| 항목 | 완료 일정 | 비고 |
|------|----------|------|
| 차시별 과정 설계서 | 12월 22일 | 12개차시 |
| Prototype 강의교안 | 12월 31일 | 1~2개 차시 |
| 12개 차시 강의교안 | 01월 23일 | 12개차시 |
| Prototype 강의 영상 | 2월 11일 | 1~2 개차시 |
| 12개 차시 강의영상 | 3월 06일 | 12개차시 |
| 수정 및 보완 | 3월 20일 | |

---

## 슬라이드 1: 표지

**강의 스크립트:**

안녕하세요, Python 시큐어코딩 교육과정에 오신 것을 환영합니다.

본 과정은 총 12차시, 740분으로 구성된 웹 애플리케이션 보안 개발 실습 과정입니다. 
Python으로 웹 애플리케이션을 개발하면서 발생할 수 있는 다양한 보안 취약점과 이를 방어하는 시큐어코딩 기법을 학습하게 됩니다.

실제 코드 예제와 실습을 통해 바로 현업에 적용할 수 있는 실용적인 지식을 습득하시기 바랍니다.

---

## 슬라이드 2: 교육과정 개요

**강의 스크립트:**

먼저 교육과정 개요를 살펴보겠습니다.

교육 목표는 Python 웹 애플리케이션의 보안 취약점을 이해하고 시큐어코딩을 실제로 적용하는 것입니다.

교육 대상은 Python 웹 개발자, 보안 담당자, 취약점 분석가입니다. Python 기초 문법과 웹 개발 기본 개념, 그리고 Flask나 Django 같은 웹 프레임워크 경험이 있으시면 수업을 따라오시는 데 무리가 없습니다.

전체 교육 시간은 740분, 약 12시간 20분입니다. 12개 차시로 나누어 진행되며, 각 차시마다 이론 설명과 실습이 함께 진행됩니다.

---

## 슬라이드 3: 차시별 구성 (1-6차시)

**강의 스크립트:**

차시별 구성을 보시겠습니다.

1차시는 시큐어코딩 개요와 SW개발보안 방법론으로, 전체 과정의 기초가 되는 내용이라 80분으로 가장 깁니다. 보안의 필요성과 기본 원칙을 학습합니다.

2차시부터는 각 60분씩 구체적인 취약점과 대응 방법을 배웁니다.
- 2차시: 입력검증과 출력 인코딩 - 모든 보안의 기초입니다
- 3차시: 명령어 인젝션 - 시스템 명령 실행 취약점
- 4차시: SQL 인젝션 - 가장 빈번하고 위험한 취약점
- 5차시: XSS - 크로스사이트스크립팅
- 6차시: CSRF와 세션관리

---

## 슬라이드 4: 차시별 구성 (7-12차시)

**강의 스크립트:**

이어서 7차시부터 12차시입니다.

- 7차시: 파일업로드와 경로조작 취약점 - 웹쉘 업로드 같은 공격을 방어합니다
- 8차시: 직렬화/역직렬화 취약점 - pickle, yaml의 위험성을 배웁니다
- 9차시: 인증 및 인가 - 로그인, 권한 관리의 보안
- 10차시: 중요정보 처리 및 암호화 - 민감 데이터 보호
- 11차시: 에러처리와 로깅 보안 - 정보 노출 방지
- 12차시: 종속성 및 패키지 공급망 보안 - 최근 급증하는 공급망 공격 대응

각 차시는 이론-코드분석-실습-정리 순서로 진행됩니다.

---

## 슬라이드 5: 실습 환경 - 안정화 버전

**강의 스크립트:**

실습에 사용할 도구들의 버전입니다. 2024년 12월 기준 안정화 버전으로 구성했습니다.

Python은 3.12.7 버전을 사용합니다. 프레임워크는 Flask 3.0.3, Django 5.1.3, FastAPI 0.115.5를 다룹니다.

보안 도구로는 Bandit, Safety, pip-audit, 그리고 OWASP ZAP을 사용합니다. 이 도구들은 실무에서도 많이 사용되는 도구들입니다.

개발 환경은 VS Code와 Docker Desktop을 사용합니다. Docker로 통일된 환경을 제공해서 설치 문제 없이 실습에 집중할 수 있습니다.

---

## 슬라이드 6: Docker 환경 구성

**강의 스크립트:**

Docker 환경 구성 방법입니다.

먼저 프로젝트 디렉토리를 만들고, docker-compose up 명령으로 실습 환경을 시작합니다. 
컨테이너에 접속한 후 bandit --version, safety --version 명령으로 보안 도구가 정상 설치되었는지 확인합니다.

만약 Docker가 익숙하지 않으시더라도 걱정하지 마세요. 제가 안내해드리는 대로 명령어만 입력하시면 됩니다.

Docker Desktop이 설치되어 있지 않으신 분은 쉬는 시간에 설치해주시기 바랍니다.

---

## 슬라이드 7: 01차시 시작 (섹션 브레이크)

**강의 스크립트:**

자, 이제 본격적으로 1차시 수업을 시작하겠습니다.

첫 번째 차시는 "시큐어코딩 개요 및 SW개발보안 방법론"입니다. 80분 동안 진행됩니다.

이번 차시에서는 왜 시큐어코딩이 필요한지, 어떤 방법론이 있는지 전체적인 그림을 그려보겠습니다. 이 내용을 이해하셔야 앞으로 배울 구체적인 취약점들이 왜 중요한지 맥락을 파악하실 수 있습니다.

---

## 슬라이드 8: 01. 학습 목표

**강의 스크립트:**

1차시 학습 목표입니다.

첫째, 소프트웨어 개발 보안이 필요한 이유와 최신 보안 위협의 특징을 설명할 수 있어야 합니다.

둘째, 실제 보안 사고 사례를 통해 취약점 발생 원인과 영향을 이해합니다. Equifax 사건, SolarWinds 사건 같은 대형 보안 사고를 살펴봅니다.

셋째, 소프트웨어 개발 보안 가이드의 핵심 원칙과 OWASP Top 10 같은 주요 취약점 유형을 이해합니다.

넷째, 보안 코딩의 기본 개념과 개발자 역할의 중요성을 인식합니다. 보안은 더 이상 보안팀만의 일이 아닙니다.

---

## 슬라이드 9: 01. 이번 차시 구성

**강의 스크립트:**

이번 차시 구성입니다.

먼저 15분간 소프트웨어 보안 위협의 변화를 살펴봅니다. 과거와 현재의 보안 패러다임이 어떻게 달라졌는지 알아봅니다.

그 다음 20분간 실제 보안 사고 사례를 분석합니다. 뉴스에서 보셨던 대형 해킹 사건들이 어떻게 발생했는지 기술적으로 살펴봅니다.

이어서 20분간 보안 SDLC와 방법론을 배웁니다. 개발 생명주기 전반에 보안을 어떻게 통합하는지 알아봅니다.

마지막 15분은 Python 생태계의 보안 특성을 다루고, 10분간 정리와 Q&A를 진행합니다.

---

## 슬라이드 10: 01. 왜 시큐어코딩인가?

**강의 스크립트:**

왜 시큐어코딩을 해야 할까요? 숫자로 말씀드리겠습니다.

2023년 전 세계 사이버 범죄 피해액이 약 8조 달러입니다. 한화로 환산하면 상상하기 어려운 금액이죠.

IBM 보고서에 따르면 데이터 유출 사고 한 건당 평균 비용이 445만 달러, 약 60억 원입니다. 그리고 이런 취약점의 70% 이상이 애플리케이션 레벨에서 발생합니다. 네트워크나 인프라가 아니라 우리가 작성한 코드에서 발생한다는 의미입니다.

운영 단계에서 취약점을 발견하면 수정 비용이 설계 단계 대비 100배나 됩니다. 그래서 개발 단계에서, 코드를 작성할 때 보안을 고려해야 합니다.

개발자가 보안의 첫 번째 방어선입니다.

---

## 슬라이드 11: 01. 소프트웨어 보안 위협의 변화

**강의 스크립트:**

보안 위협이 어떻게 변화했는지 비교해보겠습니다.

과거에는 네트워크와 인프라가 주요 공격 대상이었습니다. 방화벽을 뚫고 들어오는 단순 침입 공격이 많았죠. 그래서 배포 이후에 보안팀이 방화벽, IDS 같은 장비로 방어했습니다.

현재는 애플리케이션과 API가 주요 타깃입니다. 공격자들은 애플리케이션의 취약점을 찾아 익스플로잇합니다. 그래서 개발 단계부터 보안을 고려해야 하고, 개발팀과 보안팀이 함께 책임집니다. SAST, DAST, SCA 같은 도구들을 CI/CD 파이프라인에 통합합니다.

이것이 바로 "Shift Left"입니다. 보안을 개발 초기 단계, 즉 타임라인의 왼쪽으로 이동시키는 개념입니다.

---

## 슬라이드 12: 01. AI Coding 시대의 보안 고려사항

**강의 스크립트:**

요즘 AI 코딩 도구 많이 사용하시죠? Cursor AI, GitHub Copilot, ChatGPT 등 생산성을 크게 높여주는 도구들입니다.

하지만 새로운 보안 이슈도 있습니다.

첫째, AI가 취약한 코드를 생성할 수 있습니다. 학습 데이터에 취약한 패턴이 포함되어 있으면 그대로 재생산됩니다.

둘째, OSS 라이선스 문제입니다. 생성된 코드의 저작권이 불명확합니다.

셋째, 검증 없이 AI 생성 코드를 그대로 사용하는 것이 위험합니다.

그래서 AI를 사용할 때도 보안 요구사항을 명시하고, 생성된 코드를 반드시 검토해야 합니다. "SQL Injection 방지 코드 작성해줘"처럼 보안을 명시적으로 요청하세요.

---

## 슬라이드 13: 01. 개발 단계별 취약점 수정 비용

**강의 스크립트:**

이 그림이 Shift Left의 핵심을 보여줍니다.

설계 단계에서 취약점을 발견하면 수정 비용이 1,000달러 정도입니다. 설계 문서만 수정하면 되니까요.

개발 단계에서 발견하면 5,000달러. 코드를 수정하고 다시 테스트해야 합니다.

테스트 단계에서는 15,000달러. 여러 모듈에 영향을 줄 수 있어서 광범위한 수정이 필요할 수 있습니다.

운영 단계에서 발견하면? 10만 달러 이상입니다. 긴급 패치, 고객 공지, 법적 대응, 신뢰도 하락까지... 비용이 기하급수적으로 증가합니다.

결론은 명확합니다. 취약점은 빨리 발견할수록 비용이 적게 듭니다.

---

## 슬라이드 14: 01. 보안 사고 사례 (1) - SQL Injection

**강의 스크립트:**

첫 번째 사례, 2017년 Equifax 개인정보 유출 사건입니다.

Equifax는 미국 3대 신용평가 회사 중 하나입니다. 이 사건으로 1억 4,300만 명의 개인정보가 유출됐습니다. 미국 인구의 거의 절반이에요.

피해 보상금만 7억 달러 이상, 주가는 30% 이상 폭락했습니다.

원인이 무엇이었을까요? 화면에 있는 것처럼 문자열을 직접 쿼리에 삽입하는 코드였습니다. Apache Struts 프레임워크의 취약점과 SQL Injection이 결합된 공격이었습니다.

이런 기초적인 취약점 하나가 역사상 최대 규모의 데이터 유출로 이어진 것입니다. 4차시에서 SQL Injection을 자세히 배우겠지만, 이 사례를 기억해주세요.

---

## 슬라이드 15: 01. 보안 사고 사례 (2) - 공급망 공격

**강의 스크립트:**

두 번째 사례는 2020년 SolarWinds 사건입니다.

SolarWinds는 IT 관리 소프트웨어를 만드는 회사인데요, 해커들이 이 회사의 빌드 시스템에 침투해서 악성코드를 삽입했습니다.

그 결과 18,000개 이상의 기관이 영향을 받았습니다. 미국 재무부, 국토안보부 같은 정부 기관도 포함됐습니다.

가장 무서운 점은 9개월 동안 탐지되지 않았다는 것입니다. 왜냐하면 SolarWinds의 공식 업데이트처럼 보였고, 디지털 서명까지 되어 있었거든요.

이것이 공급망 공격의 무서움입니다. 신뢰할 수 있는 경로를 통해 들어오기 때문에 탐지가 어렵습니다. 12차시에서 이런 공급망 보안을 다룹니다.

---

## 슬라이드 16: 01. OWASP Top 10 (2021)

**강의 스크립트:**

OWASP Top 10은 웹 애플리케이션의 가장 위험한 10가지 취약점 목록입니다. 2021년 버전입니다.

1위는 Broken Access Control, 접근 제어 실패입니다. 권한 없는 사용자가 다른 사용자의 데이터에 접근하는 것이죠.

2위는 암호화 실패, 민감한 데이터가 평문으로 저장되거나 전송되는 경우입니다.

3위가 우리가 배울 Injection입니다. SQL, Command Injection 등이 여기 포함됩니다.

이 외에도 안전하지 않은 설계, 보안 설정 오류, 취약한 컴포넌트 사용, 인증 실패 등이 있습니다.

이 10가지 취약점이 실제 공격의 대부분을 차지합니다. 본 과정에서 이 취약점들을 대부분 다룹니다.

---

## 슬라이드 17: 01. 보안 SDLC 개요

**강의 스크립트:**

보안 SDLC, 즉 보안이 통합된 소프트웨어 개발 생명주기입니다.

요구사항 단계에서는 보안 요구사항을 정의하고 위험을 평가합니다. "이 시스템이 어떤 보안 위협에 노출될 수 있는가?"를 분석합니다.

설계 단계에서는 위협 모델링을 수행합니다. 시스템 아키텍처에서 공격 포인트를 식별합니다.

구현 단계가 바로 시큐어코딩입니다. 오늘 배우는 내용이 여기에 해당합니다. 코드 리뷰도 이 단계에서 이루어집니다.

테스트 단계에서는 SAST(정적 분석), DAST(동적 분석), 침투 테스트를 수행합니다.

배포 후에는 보안 설정을 검증하고 지속적으로 모니터링합니다.

각 단계마다 보안 활동이 있다는 것이 핵심입니다.

---

## 슬라이드 18: 01. Python 생태계 보안 특성

**강의 스크립트:**

Python만의 보안 특성을 알아보겠습니다.

Python은 동적 타입 언어입니다. 타입 검증이 런타임에 이루어지다 보니 타입 관련 버그가 보안 취약점으로 이어질 수 있습니다. Pydantic 같은 타입 힌트 라이브러리로 대응합니다.

eval()과 exec() 함수는 문자열을 코드로 실행합니다. 사용자 입력이 여기에 들어가면 코드 인젝션이 발생합니다. 사용을 금지해야 합니다.

pickle은 객체 직렬화에 많이 쓰이는데, 원격 코드 실행 취약점이 있습니다. 8차시에서 자세히 배웁니다.

마지막으로 pip 패키지입니다. PyPI에 악성 패키지가 올라오는 공급망 공격이 빈번합니다. 버전을 고정하고 해시를 검증해야 합니다.

---

## 슬라이드 19: 01. 시큐어코딩 7대 원칙

**강의 스크립트:**

이 과정에서 배울 시큐어코딩의 7대 원칙입니다. 잘 기억해두세요.

첫째, 입력값 검증. 모든 입력은 잠재적 공격입니다. 신뢰하지 마세요.

둘째, 출력 인코딩. HTML에 출력할 때, URL에 포함할 때, 컨텍스트에 맞게 인코딩합니다.

셋째, 인증 및 인가. 사용자가 누구인지 확인하고, 무엇을 할 수 있는지 검증합니다.

넷째, 세션 관리. 안전하게 세션을 생성, 유지, 종료합니다.

다섯째, 암호화. 민감한 데이터는 암호화해서 저장하고 전송합니다.

여섯째, 에러 처리. 에러 메시지로 시스템 정보가 노출되지 않게 합니다.

일곱째, 로깅. 보안 이벤트를 기록해서 사후 분석에 활용합니다.

이 7가지 원칙이 이 과정의 뼈대입니다.

---

## 슬라이드 20: 01. 실습 환경 확인

**강의 스크립트:**

자, 이제 실습 환경을 확인해보겠습니다.

터미널을 열고 docker exec 명령으로 컨테이너에 접속합니다.

python --version으로 Python 버전을 확인합니다. 3.12.7이 나와야 합니다.

bandit --version과 safety --version으로 보안 도구가 설치되었는지 확인합니다.

그리고 pip show flask django fastapi로 프레임워크 설치도 확인합니다.

지금 시간을 드릴 테니 각자 환경에서 확인해보세요. 안 되시는 분은 손 들어주세요.

---

## 슬라이드 21: 01. 정리 - 핵심 포인트

**강의 스크립트:**

1차시 핵심 포인트를 정리하겠습니다.

첫째, 보안 위협의 대상이 네트워크에서 애플리케이션으로 이동했습니다.

둘째, Shift Left입니다. 개발 초기 단계에서 보안을 적용하는 것이 비용 효율적입니다.

셋째, SQL Injection, 공급망 공격으로 수억 달러의 피해가 발생했습니다. 남의 일이 아닙니다.

넷째, OWASP Top 10을 기억하세요. 가장 빈번한 취약점 목록입니다.

다섯째, Python의 eval, exec, pickle은 특히 주의해야 합니다.

여섯째, 시큐어코딩 7대 원칙을 항상 염두에 두세요.

다음 차시부터 이 원칙들을 하나씩 구체적으로 배워나가겠습니다.

---

## 슬라이드 22: 01. 확인 문제

**강의 스크립트:**

학습 내용을 확인하는 문제입니다. 잠시 생각해보세요.

첫째, Shift Left 보안이란 무엇이며 왜 중요한가요?
→ 보안을 개발 초기 단계로 이동시키는 것입니다. 취약점을 빨리 발견할수록 수정 비용이 낮기 때문입니다.

둘째, OWASP Top 10 중 가장 위험한 3가지는?
→ 1위 접근제어 실패, 2위 암호화 실패, 3위 인젝션입니다.

셋째, Python에서 사용을 피해야 할 위험 함수 3가지는?
→ eval(), exec(), pickle.loads()입니다.

넷째, 운영 단계 취약점 수정 비용은 설계 단계 대비 몇 배?
→ 약 100배입니다.

질문 있으신 분? 없으시면 10분 쉬고 2차시 시작하겠습니다.

---

## 슬라이드 23: 02차시 시작 (섹션 브레이크)

**강의 스크립트:**

자, 2차시를 시작하겠습니다.

"입력검증과 출력 인코딩"입니다. 60분간 진행됩니다.

이번 차시는 시큐어코딩의 가장 기본이 되는 내용입니다. 모든 보안 취약점의 대부분은 입력값을 제대로 검증하지 않아서 발생합니다. 그리고 출력할 때 제대로 인코딩하지 않아서 XSS 같은 공격이 가능해집니다.

이 두 가지만 제대로 해도 상당수의 취약점을 예방할 수 있습니다.

---

## 슬라이드 24: 02. 학습 목표

**강의 스크립트:**

2차시 학습 목표입니다.

첫째, 입력값 검증의 필요성과 검증 실패로 인한 보안 취약점을 설명할 수 있어야 합니다.

둘째, 정규표현식, 경계값 검사, 타입 검사 같은 검증 기법을 이해하고 실제로 적용할 수 있어야 합니다.

셋째, 출력 인코딩의 개념을 이해하고 안전한 출력값을 생성할 수 있어야 합니다. HTML 인코딩, URL 인코딩 등을 다룹니다.

넷째, Python에서 입력 검증과 출력 인코딩을 위한 라이브러리를 활용할 수 있어야 합니다. Pydantic, markupsafe 등을 사용합니다.

---

## 슬라이드 25: 02. 이번 차시 구성

**강의 스크립트:**

이번 차시 구성입니다.

10분간 입력값 검증 개요를 살펴봅니다. 왜 검증해야 하는지, 어떤 입력이 위험한지 알아봅니다.

15분간 구체적인 검증 기법을 배웁니다. 화이트리스트, 블랙리스트, 정규표현식, Pydantic을 이용한 타입 검사 등입니다.

10분간 출력 인코딩을 다룹니다. HTML, URL, JSON 컨텍스트별 인코딩 방법을 배웁니다.

20분은 실습 시간입니다. 실제로 회원가입 폼의 입력값을 검증하는 코드를 작성해봅니다.

마지막 5분은 정리와 Q&A입니다.

---

## 슬라이드 26: 02. 입력값 검증이 필요한 이유

**강의 스크립트:**

모든 입력은 신뢰할 수 없습니다. 이것이 가장 중요한 원칙입니다.

신뢰할 수 없는 입력 소스를 보세요. URL 파라미터, POST 데이터, HTTP 헤더, 쿠키, 파일 업로드, API 요청 본문... 사용자가 조작할 수 있는 모든 것이 위험합니다.

심지어 데이터베이스 조회 결과도 주의해야 합니다. 이전에 공격자가 오염된 데이터를 저장해뒀을 수 있거든요.

원칙을 기억하세요: "모든 입력은 악의적일 수 있다고 가정한다."

검증 실패 시 발생하는 취약점들을 보세요. SQL Injection, Command Injection, XSS, Path Traversal... 이 과정에서 배울 대부분의 취약점이 입력 검증 실패에서 시작됩니다.

---

## 슬라이드 27: 02. 입력값 검증 원칙

**강의 스크립트:**

검증 방식에는 화이트리스트와 블랙리스트 두 가지가 있습니다.

화이트리스트는 허용된 값만 통과시킵니다. 예를 들어 파일 확장자가 png, jpg, gif 중 하나인 경우에만 허용합니다.

블랙리스트는 금지된 값만 차단합니다. exe, bat 같은 위험한 확장자를 막는 방식이죠.

어떤 게 더 안전할까요? 화이트리스트입니다.

블랙리스트는 우회가 가능합니다. exe, bat을 막아도 php, jsp, phtml 같은 다른 위험한 확장자가 있을 수 있습니다. 공격자는 항상 새로운 우회 방법을 찾습니다.

화이트리스트는 "허용된 것만 통과"이므로 새로운 공격 방법이 나와도 기본적으로 차단됩니다.

항상 화이트리스트 방식을 사용하세요.

---

## 슬라이드 28: 02. 정규표현식 검증

**강의 스크립트:**

정규표현식을 이용한 검증 예제입니다.

validate_email 함수는 이메일 형식을 검증합니다. 알파벳, 숫자, 일부 특수문자, @, 도메인 형식을 확인합니다.

validate_phone_korea는 한국 전화번호 형식입니다. 01로 시작하고 숫자가 이어지는 패턴을 검사합니다.

validate_password_strength는 비밀번호 강도를 검사합니다. 8자 이상, 대문자 포함, 소문자 포함, 숫자 포함을 확인합니다.

정규표현식은 강력하지만 복잡해지면 읽기 어려워집니다. 또한 ReDoS(정규표현식 서비스 거부) 공격에 취약할 수 있으니, 복잡한 패턴보다는 단순한 패턴을 여러 개 조합하는 것이 좋습니다.

---

## 슬라이드 29: 02. 타입 검사 - Pydantic 활용

**강의 스크립트:**

Pydantic은 Python에서 가장 많이 쓰이는 데이터 검증 라이브러리입니다. FastAPI의 기본 검증 도구이기도 합니다.

UserRegistration 클래스를 보세요. BaseModel을 상속받습니다.

username 필드는 문자열인데, Field로 최소 3자, 최대 20자 제한을 둡니다. email은 EmailStr 타입으로 이메일 형식을 자동 검증합니다. age는 정수형이고, 0 이상 150 이하로 제한합니다.

@validator 데코레이터로 추가 검증도 가능합니다. username이 알파벳과 숫자로만 구성되어 있는지 확인합니다.

사용할 때는 UserRegistration 객체를 생성하면 됩니다. 검증에 실패하면 ValidationError 예외가 발생합니다.

Pydantic을 사용하면 타입 안전성과 입력 검증을 한 번에 해결할 수 있습니다.

---

## 슬라이드 30: 02. 출력 인코딩

**강의 스크립트:**

이제 출력 인코딩입니다.

입력을 검증했다고 끝이 아닙니다. 데이터를 출력할 때도 인코딩해야 합니다.

HTML 인코딩을 보겠습니다. markupsafe 라이브러리의 escape 함수를 사용합니다.

사용자가 `<script>alert("XSS")</script>`를 입력했다고 해봅시다. 이걸 그대로 HTML에 출력하면 스크립트가 실행됩니다.

하지만 escape 함수를 통과하면 `<`가 `&lt;`로, `>`가 `&gt;`로 변환됩니다. 브라우저는 이것을 코드가 아니라 텍스트로 인식합니다. XSS 공격이 무력화되는 거죠.

URL 인코딩도 마찬가지입니다. 공백이나 한글 같은 특수문자를 URL에 포함할 때는 quote나 urlencode를 사용합니다.

---

## 슬라이드 31: 02. Flask 템플릿 자동 이스케이핑

**강의 스크립트:**

Flask의 Jinja2 템플릿은 기본적으로 자동 이스케이핑이 활성화되어 있습니다.

`{{ user_input }}`으로 출력하면 자동으로 HTML 인코딩됩니다. 직접 escape 함수를 호출할 필요가 없습니다.

그런데 `{{ user_input | safe }}` 필터를 쓰면 이스케이핑이 비활성화됩니다. 이건 정말 신뢰할 수 있는 데이터, 예를 들어 관리자가 작성한 HTML 컨텐츠에만 사용해야 합니다.

사용자 입력에는 절대 safe 필터를 쓰면 안 됩니다.

Django도 마찬가지로 기본 자동 이스케이핑을 제공합니다. `{{ value }}`는 안전하고, `{{ value | safe }}`나 `{% autoescape off %}`는 주의해야 합니다.

프레임워크의 보안 기능을 믿고, 일부러 비활성화하지 마세요.

---

## 슬라이드 32: 02. 실습: 회원가입 폼 검증

**강의 스크립트:**

이제 실습 시간입니다. 20분간 진행합니다.

회원가입 폼 검증을 구현합니다. 검증 요구사항을 보세요.

username은 3~20자, 영문자와 숫자만 허용합니다.
email은 이메일 형식이어야 합니다.
password는 8자 이상, 대문자, 소문자, 숫자, 특수문자를 모두 포함해야 합니다.
age는 0~150 범위입니다.

실습 디렉토리로 이동해서 app.py를 실행하세요. 먼저 취약한 코드를 확인하고, Pydantic을 사용해서 검증을 추가해보세요.

모르시는 부분은 질문해주세요. 저도 돌아다니면서 도와드리겠습니다.

---

## 슬라이드 33: 02. 정리 - 핵심 포인트

**강의 스크립트:**

2차시 핵심 포인트입니다.

입력값 검증의 핵심:
1. 모든 입력은 신뢰하지 않습니다.
2. 화이트리스트 방식을 사용합니다.
3. 클라이언트 검증은 사용자 편의를 위한 것이고, 서버에서 반드시 다시 검증해야 합니다. 클라이언트 검증은 우회할 수 있습니다.
4. Pydantic으로 타입 안전성을 확보합니다.

출력 인코딩의 핵심:
1. HTML, URL, JSON 등 컨텍스트에 맞게 인코딩합니다.
2. 프레임워크의 자동 이스케이핑을 활용합니다.
3. safe 필터는 최소화합니다.

---

## 슬라이드 34: 02. 확인 문제

**강의 스크립트:**

확인 문제입니다.

첫째, 화이트리스트와 블랙리스트 검증의 차이점은?
→ 화이트리스트는 허용된 것만 통과, 블랙리스트는 금지된 것만 차단. 화이트리스트가 더 안전합니다.

둘째, 클라이언트 검증만으로 충분하지 않은 이유는?
→ 클라이언트 검증은 JavaScript를 비활성화하거나 브라우저 개발자 도구로 우회할 수 있습니다.

셋째, HTML 컨텍스트에서 `<` 문자는 어떻게 인코딩되나요?
→ `&lt;`로 인코딩됩니다.

넷째, Pydantic의 @validator 데코레이터 용도는?
→ 필드별 커스텀 검증 로직을 추가할 때 사용합니다.

---

## 슬라이드 35: 03차시 시작 (섹션 브레이크)

**강의 스크립트:**

3차시, "인젝션 - 명령어"입니다. 60분간 진행됩니다.

인젝션은 사용자 입력이 명령어나 쿼리의 일부로 실행되는 취약점입니다. OWASP Top 10의 3위입니다.

이번 차시에서는 운영체제 명령어 인젝션을 다룹니다. 시스템 명령을 실행하는 코드에서 발생하는 취약점입니다.

다음 차시에서는 SQL 인젝션을 배웁니다.

---

## 슬라이드 36: 03. 학습 목표

**강의 스크립트:**

3차시 학습 목표입니다.

첫째, 명령어 인젝션 취약점의 발생 원리와 위험성을 설명할 수 있어야 합니다.

둘째, subprocess, os.system 같은 시스템 명령 실행 함수의 보안 취약점을 이해합니다.

셋째, Bandit 같은 도구로 명령어 인젝션 취약점을 진단하고 식별할 수 있어야 합니다.

넷째, 안전한 시스템 명령 실행을 위한 시큐어코딩 기법을 적용할 수 있어야 합니다. shell=False 옵션, 입력 검증 등을 배웁니다.

---

## 슬라이드 37: 03. 이번 차시 구성

**강의 스크립트:**

이번 차시 구성입니다.

10분간 명령어 인젝션 개요를 살펴봅니다.

15분간 취약한 코드를 분석합니다. 실제로 어떤 코드가 위험한지 보겠습니다.

15분간 안전한 코드 작성법을 배웁니다. subprocess를 안전하게 사용하는 방법입니다.

15분은 실습 시간입니다. Bandit으로 취약점을 진단하고 수정해봅니다.

5분간 정리와 Q&A를 진행합니다.

---

## 슬라이드 38: 03. 명령어 인젝션이란?

**강의 스크립트:**

명령어 인젝션은 사용자 입력이 시스템 명령어의 일부로 실행되어 의도하지 않은 명령이 실행되는 취약점입니다.

어떻게 가능할까요? 쉘 메타문자 때문입니다.

세미콜론(;)은 명령을 구분합니다. `ping google.com; cat /etc/passwd`를 입력하면 ping 실행 후 passwd 파일이 출력됩니다.

파이프(|)는 앞 명령의 출력을 뒤 명령의 입력으로 전달합니다.

&&는 앞 명령이 성공하면 뒤 명령을 실행합니다.

$()는 명령 치환입니다. `$(whoami)`는 현재 사용자 이름으로 대체됩니다.

공격자는 이런 메타문자를 이용해서 원하는 명령을 주입합니다.

---

## 슬라이드 39: 03. 취약한 코드 예시

**강의 스크립트:**

취약한 코드를 보겠습니다.

ping_host 함수가 hostname을 받아서 os.system으로 ping 명령을 실행합니다.

정상적으로 google.com을 입력하면 `ping -c 3 google.com`이 실행됩니다. 문제없죠.

그런데 공격자가 `google.com; cat /etc/passwd`를 입력하면 어떻게 될까요?

실행되는 명령은 `ping -c 3 google.com; cat /etc/passwd`입니다. ping 실행 후 /etc/passwd 파일 내용이 출력됩니다. 시스템의 사용자 목록이 노출되는 거죠.

더 심하게는 `; rm -rf /`로 파일 시스템 전체를 삭제할 수도 있습니다.

os.system은 쉘을 통해 명령을 실행하기 때문에 이런 공격이 가능합니다.

---

## 슬라이드 40: 03. Python 위험 함수 목록

**강의 스크립트:**

Python에서 명령어 인젝션에 취약한 함수들입니다.

os.system()과 os.popen()은 쉘을 통해 명령을 실행합니다. 위험도 높음입니다.

subprocess를 shell=True로 사용해도 마찬가지입니다. 쉘을 거치기 때문에 메타문자가 해석됩니다.

eval()과 exec()는 문자열을 Python 코드로 실행합니다. 명령어 인젝션보다 더 위험할 수 있습니다. 공격자가 Python 코드를 직접 실행할 수 있으니까요.

안전한 대안은 subprocess를 shell=False로 사용하는 것입니다. 그리고 eval 대신 ast.literal_eval을 사용합니다.

---

## 슬라이드 41: 03. 안전한 명령 실행

**강의 스크립트:**

안전한 명령 실행 방법입니다.

먼저 입력값을 검증합니다. hostname이 알파벳, 숫자, 점, 하이픈으로만 구성되어 있는지 확인합니다. 세미콜론, 파이프 같은 메타문자가 있으면 거부합니다.

그 다음 subprocess.run을 사용합니다. 핵심은 세 가지입니다.

첫째, shell=False입니다. 기본값이 False지만 명시적으로 적어주세요.

둘째, 명령어와 인자를 리스트로 전달합니다. `["ping", "-c", "3", hostname]` 이렇게요. 문자열 하나로 전달하면 안 됩니다.

셋째, timeout을 설정합니다. 악의적인 명령이 무한히 실행되는 것을 방지합니다.

이렇게 하면 hostname에 메타문자가 있어도 그냥 ping의 인자로 전달될 뿐, 별도 명령으로 해석되지 않습니다.

---

## 슬라이드 42: 03. Bandit을 이용한 취약점 진단

**강의 스크립트:**

Bandit은 Python 코드의 보안 취약점을 찾아주는 정적 분석 도구입니다.

bandit -r ./src 명령으로 src 디렉토리 전체를 검사합니다. -f html -o report.html 옵션으로 HTML 리포트를 생성할 수도 있습니다.

결과를 보면 B602 경고가 나옵니다. subprocess_popen_with_shell_equals_true, 즉 shell=True를 사용한 곳을 잡아냅니다.

Severity: High, Confidence: High로 나옵니다. 확실히 위험하다는 의미입니다.

Location에서 어느 파일의 몇 번째 줄인지 알려줍니다.

Bandit을 CI/CD 파이프라인에 넣어서 매 커밋마다 자동 검사하는 것을 권장합니다.

---

## 슬라이드 43: 03. 실습: 취약점 진단 및 수정

**강의 스크립트:**

실습 시간입니다.

실습 디렉토리로 이동해서 vulnerable_app.py 파일을 확인합니다.

먼저 Bandit으로 취약점을 진단합니다. 어떤 경고가 나오나요?

그 다음 취약한 앱을 실행하고, 메타문자를 포함한 입력으로 공격을 시도해봅니다.

실습 목표는 네 가지입니다:
1. Bandit으로 취약점 식별
2. 취약점 원인 분석 - 왜 이게 위험한지 이해
3. 안전한 코드로 수정 - shell=False와 리스트 인자 사용
4. 수정 후 재검사 - Bandit 경고가 사라지는지 확인

15분 드리겠습니다. 시작하세요.

---

## 슬라이드 44: 03. 정리 - 핵심 포인트

**강의 스크립트:**

3차시 핵심 포인트입니다.

1. os.system(), os.popen() 사용 금지입니다. 이 함수들은 보안상 안전하게 사용할 방법이 없습니다.

2. subprocess 사용 시 shell=False 필수입니다. 기본값이 False지만 명시적으로 적으세요.

3. 명령어 인자는 리스트로 전달합니다. 문자열 하나로 전달하지 마세요.

4. 사용자 입력은 화이트리스트로 검증합니다. 허용된 문자만 통과시킵니다.

5. 가능하면 시스템 명령 대신 Python 라이브러리를 사용하세요. 예를 들어 ping 대신 socket 라이브러리를 사용할 수 있습니다.

6. eval/exec는 사용 금지입니다.

7. Bandit으로 정기적으로 검사합니다.

---

## 슬라이드 45: 03. 확인 문제

**강의 스크립트:**

확인 문제입니다.

첫째, 명령어 인젝션에 사용되는 쉘 메타문자 3가지는?
→ 세미콜론(;), 파이프(|), &&, $() 등입니다.

둘째, subprocess.run() 안전 사용을 위한 필수 옵션은?
→ shell=False입니다. 그리고 명령어와 인자를 리스트로 전달해야 합니다.

셋째, eval() 함수의 안전한 대안은?
→ ast.literal_eval입니다. 리터럴만 평가하고 코드 실행은 하지 않습니다.

넷째, Bandit B602 경고의 원인은?
→ subprocess에서 shell=True를 사용했기 때문입니다.

---

## 슬라이드 46: 04차시 시작 (섹션 브레이크)

**강의 스크립트:**

4차시, "인젝션 - SQL"입니다. 60분간 진행됩니다.

SQL Injection은 가장 오래되고, 가장 빈번하며, 가장 위험한 취약점 중 하나입니다. 1998년에 처음 발견된 이후로 20년 넘게 Top 10 취약점에 포함되어 있습니다.

앞서 Equifax 사례에서 봤듯이, SQL Injection 하나로 1억 명 이상의 개인정보가 유출될 수 있습니다.

---

## 슬라이드 47: 04. 학습 목표

**강의 스크립트:**

4차시 학습 목표입니다.

첫째, SQL 인젝션 취약점의 발생 원리와 공격 유형을 설명할 수 있어야 합니다. Classic, Blind, Union-based 등 다양한 유형이 있습니다.

둘째, Python DB-API와 ORM을 활용한 안전한 데이터베이스 접근 방법을 이해합니다.

셋째, 파라미터 바인딩을 통한 안전한 쿼리 처리 기법을 적용할 수 있어야 합니다. 이것이 SQL Injection 방어의 핵심입니다.

넷째, RAW SQL 사용 시 보안 주의사항을 인식하고 준수해야 합니다.

---

## 슬라이드 48: 04. SQL Injection 공격 원리

**강의 스크립트:**

취약한 코드를 보겠습니다.

login 함수가 username과 password를 받아서 f-string으로 SQL 쿼리를 만듭니다. 이게 전형적인 취약 패턴입니다.

정상 입력으로 admin, password123을 넣으면 `SELECT * FROM users WHERE username='admin' AND password='password123'`이 실행됩니다.

그런데 username에 `admin'--`를 입력하면 어떻게 될까요?

쿼리는 `SELECT * FROM users WHERE username='admin'--' AND password='...'`가 됩니다. 작은따옴표로 문자열을 닫고, --는 SQL 주석입니다. 비밀번호 조건이 무시됩니다.

`' OR '1'='1`을 입력하면 WHERE 조건이 항상 참이 되어 모든 레코드가 반환됩니다.

---

## 슬라이드 49: 04. SQL Injection 공격 유형

**강의 스크립트:**

SQL Injection 공격 유형입니다.

In-band 또는 Classic은 결과가 직접 화면에 표시됩니다. 가장 기본적인 형태입니다.

Error-based는 데이터베이스 에러 메시지에서 정보를 추출합니다. 에러 메시지에 테이블명이나 컬럼명이 노출될 수 있습니다.

Union-based는 UNION을 이용해서 다른 테이블의 데이터를 조회합니다. 예를 들어 `' UNION SELECT username, password FROM admins--`처럼요.

Blind Boolean은 응답의 참/거짓 차이를 관찰합니다. "결과가 있음/없음"만으로도 한 글자씩 정보를 추출할 수 있습니다.

Blind Time은 응답 시간 차이를 이용합니다. `IF(조건, SLEEP(5), 0)` 같은 방식으로 시간 지연을 관찰합니다.

---

## 슬라이드 50: 04. 파라미터 바인딩

**강의 스크립트:**

SQL Injection 방어의 핵심, 파라미터 바인딩입니다.

안전한 코드를 보세요. 쿼리에서 사용자 입력 자리에 물음표(?)를 씁니다. 그리고 실제 값은 튜플로 따로 전달합니다.

이렇게 하면 데이터베이스 드라이버가 값을 안전하게 처리합니다. username에 `admin'--`를 넣어도 그냥 문자열 `admin'--`로 검색됩니다. SQL 구문으로 해석되지 않습니다.

왜냐하면 파라미터 바인딩은 SQL 쿼리의 구조와 데이터를 분리하기 때문입니다. 쿼리 구조는 먼저 컴파일되고, 데이터는 나중에 들어갑니다.

SQLite는 물음표(?), MySQL과 PostgreSQL은 %s 또는 %(name)s를 사용합니다. 프레임워크마다 조금씩 다르지만 원리는 같습니다.

---

## 슬라이드 51: 04. SQLAlchemy ORM

**강의 스크립트:**

SQLAlchemy ORM을 사용하면 더 안전합니다.

session.query(User).filter(User.username == username) 이렇게 ORM 메서드를 사용하면 자동으로 파라미터 바인딩이 됩니다.

RAW SQL을 써야 할 때도 text() 함수와 바인딩을 사용합니다. 콜론(:)으로 파라미터 이름을 표시하고, 딕셔너리로 값을 전달합니다.

절대 f-string이나 format으로 쿼리를 만들면 안 됩니다. 코드에서 이런 패턴이 보이면 즉시 수정해야 합니다.

ORM을 사용하면 SQL Injection 걱정이 거의 없어집니다. 그래서 가능하면 RAW SQL보다 ORM을 권장합니다.

---

## 슬라이드 52: 04. Django ORM

**강의 스크립트:**

Django ORM도 마찬가지입니다.

filter()로 조건을 걸면 자동으로 안전하게 처리됩니다. Q 객체로 복잡한 조건도 만들 수 있습니다.

raw() 메서드를 사용할 때는 반드시 파라미터를 리스트로 전달하세요. %s 플레이스홀더를 사용합니다.

절대로 f-string으로 raw() 쿼리를 만들면 안 됩니다. 빨간색으로 표시된 코드처럼요. 이건 SQL Injection에 완전히 취약합니다.

Django ORM의 QuerySet 메서드들(filter, exclude, get 등)은 모두 안전합니다. 가능하면 이것들을 사용하세요.

---

## 슬라이드 53: 04. 실습

**강의 스크립트:**

실습 시간입니다.

실습 디렉토리에서 취약한 로그인 앱을 실행합니다. curl로 공격 페이로드를 보내봅니다. `admin'--`로 비밀번호 없이 로그인되는지 확인하세요.

그 다음 파라미터 바인딩을 적용해서 코드를 수정합니다. 수정 후 같은 공격이 막히는지 확인하세요.

15분간 진행합니다.

---

## 슬라이드 54: 04. 정리

**강의 스크립트:**

4차시 핵심 포인트입니다.

1. 문자열 포맷팅으로 쿼리 생성 금지입니다. f-string, format, % 연산자 모두 위험합니다.

2. 항상 파라미터 바인딩을 사용합니다. 이것이 SQL Injection 방어의 핵심입니다.

3. ORM 사용을 권장합니다. SQLAlchemy, Django ORM은 기본적으로 안전합니다.

4. Raw SQL 사용 시 반드시 파라미터 바인딩합니다.

5. 입력값 추가 검증도 좋습니다. 길이 제한, 특수문자 검사 등 다중 방어를 적용하세요.

6. 데이터베이스 계정은 최소 권한 원칙을 따릅니다. 애플리케이션 계정에서 DROP, ALTER 권한은 필요 없습니다.

7. 에러 메시지에 SQL 정보를 노출하지 마세요.

---

## 슬라이드 55: 04. 확인 문제

**강의 스크립트:**

확인 문제입니다.

첫째, SQL Injection 주요 공격 유형 3가지는?
→ In-band(Classic), Blind Boolean, Blind Time, Union-based, Error-based 중 3가지입니다.

둘째, 파라미터 바인딩이 안전한 이유는?
→ SQL 구조와 데이터를 분리해서, 사용자 입력이 SQL 구문으로 해석되지 않습니다.

셋째, Django ORM에서 raw() 안전 사용법은?
→ 플레이스홀더(%s)를 사용하고 파라미터를 리스트로 전달합니다.

넷째, `admin'--` 페이로드의 효과는?
→ 작은따옴표로 문자열을 닫고 --로 나머지를 주석 처리해서 비밀번호 검증을 우회합니다.

---

## 슬라이드 56: 05차시 시작 (XSS)

**강의 스크립트:**

5차시, "크로스사이트스크립팅(XSS)"입니다.

XSS는 공격자가 웹 페이지에 악성 스크립트를 삽입하는 취약점입니다. 피해자의 브라우저에서 그 스크립트가 실행됩니다.

쿠키 탈취, 키로깅, 피싱, 악성코드 배포 등 다양한 공격이 가능합니다. OWASP Top 10에서 꾸준히 상위권입니다.

---

## 슬라이드 57-67: 05차시 XSS 상세

**강의 스크립트:**

(각 슬라이드별 상세 설명 - XSS 유형, Stored/Reflected/DOM-based 차이, 출력 인코딩, CSP 헤더, HTTPOnly 쿠키 등)

핵심은:
- Stored XSS: DB에 저장되어 모든 방문자에게 영향
- Reflected XSS: URL 파라미터를 통해 특정 피해자만
- 방어: 출력 시 HTML 인코딩, CSP 헤더, HTTPOnly 쿠키
- 템플릿 자동 이스케이핑 활용, |safe 필터 최소화

---

## 슬라이드 68: 06차시 시작 (CSRF)

**강의 스크립트:**

6차시, "CSRF와 세션관리"입니다.

CSRF는 Cross-Site Request Forgery의 약자입니다. 공격자가 피해자 대신 요청을 보내는 공격입니다.

피해자가 은행에 로그인한 상태에서 악성 사이트를 방문하면, 악성 사이트가 피해자 대신 은행에 송금 요청을 보낼 수 있습니다.

XSS와 헷갈리기 쉬운데요, XSS는 스크립트를 실행하는 것이고, CSRF는 요청을 위조하는 것입니다.

---

## 슬라이드 69-79: 06차시 CSRF/세션 상세

**강의 스크립트:**

(각 슬라이드별 설명 - CSRF 토큰, Flask-WTF, Django CSRF, SameSite 쿠키, 세션 보안 설정 등)

핵심은:
- 모든 상태 변경 요청에 CSRF 토큰 필수
- SameSite=Lax 이상 쿠키 설정
- 로그인 시 세션 재생성 (세션 고정 공격 방지)
- HTTPOnly, Secure 쿠키 플래그

---

## 슬라이드 80: 07차시 시작 (파일업로드)

**강의 스크립트:**

7차시, "파일업로드 및 경로조작 취약점"입니다.

파일 업로드는 웹쉘 업로드로 서버를 장악할 수 있는 위험한 기능입니다. 경로 조작은 ../를 이용해서 의도하지 않은 파일에 접근하는 공격입니다.

두 가지 모두 파일 시스템과 관련된 취약점입니다.

---

## 슬라이드 81-91: 07차시 파일보안 상세

**강의 스크립트:**

(각 슬라이드별 설명 - 웹쉘, 확장자 검증, MIME 타입, Path Traversal, secure_filename, resolve() 등)

핵심은:
- 확장자 화이트리스트 검증
- 파일 내용(매직 바이트) 검증
- 파일명 UUID로 재생성
- 업로드 디렉토리 실행 권한 제거
- 경로는 resolve()로 정규화 후 기준 디렉토리 검증

---

## 슬라이드 92: 08차시 시작 (직렬화)

**강의 스크립트:**

8차시, "직렬화/역직렬화 취약점"입니다.

Python의 pickle 모듈은 객체를 바이트로 변환하고 복원합니다. 그런데 이 과정에서 임의의 코드가 실행될 수 있습니다.

신뢰할 수 없는 데이터를 pickle.loads()로 역직렬화하면 원격 코드 실행(RCE)이 가능합니다. 매우 위험한 취약점입니다.

---

## 슬라이드 93-103: 08차시 직렬화 상세

**강의 스크립트:**

(각 슬라이드별 설명 - pickle __reduce__, YAML 취약점, JSON 대안, itsdangerous 등)

핵심은:
- pickle.loads()에 신뢰할 수 없는 데이터 절대 금지
- yaml.safe_load() 사용 (yaml.load() 금지)
- JSON 사용 권장
- 필요시 itsdangerous로 서명된 직렬화

---

## 슬라이드 104: 09차시 시작 (인증/인가)

**강의 스크립트:**

9차시, "인증 및 인가"입니다.

인증은 "당신은 누구인가?", 인가는 "무엇을 할 수 있는가?"입니다. 로그인은 인증, 권한 체크는 인가입니다.

비밀번호 저장, 브루트포스 방어, JWT 토큰, RBAC 등을 다룹니다.

---

## 슬라이드 105-115: 09차시 인증/인가 상세

**강의 스크립트:**

(각 슬라이드별 설명 - bcrypt/argon2, 솔팅, 브루트포스 방어, JWT, RBAC 등)

핵심은:
- bcrypt 또는 argon2로 비밀번호 해시
- MD5, SHA256 사용 금지 (솔트 없음, 빠른 해시)
- 로그인 시도 횟수 제한 (flask-limiter)
- JWT는 HS256 이상, 만료 시간 설정
- 역할 기반 접근 제어 구현

---

## 슬라이드 116: 10차시 시작 (암호화)

**강의 스크립트:**

10차시, "중요정보 처리 및 암호화"입니다.

개인정보, 금융정보, 의료정보 같은 민감한 데이터는 암호화해서 저장해야 합니다. 암호화 키 관리도 매우 중요합니다.

---

## 슬라이드 117-127: 10차시 암호화 상세

**강의 스크립트:**

(각 슬라이드별 설명 - 대칭키/비대칭키, Fernet, 키 관리, 환경변수, 마스킹 등)

핵심은:
- AES-256 같은 강력한 알고리즘 사용
- 키는 환경변수 또는 시크릿 매니저에 보관
- 하드코딩 절대 금지
- 로그와 화면에는 마스킹 처리
- 전송 시 TLS 사용

---

## 슬라이드 128: 11차시 시작 (에러/로깅)

**강의 스크립트:**

11차시, "에러처리 및 로깅 보안"입니다.

에러 메시지로 시스템 정보가 노출되면 공격에 활용됩니다. 로그에 비밀번호가 기록되면 로그 접근 권한이 있는 사람이 볼 수 있습니다.

---

## 슬라이드 129-139: 11차시 에러/로깅 상세

**강의 스크립트:**

(각 슬라이드별 설명 - 정보 노출, 에러 핸들러, 마스킹 필터, 보안 이벤트 로깅 등)

핵심은:
- 상세 에러는 내부 로깅만, 사용자에게는 일반 메시지
- DEBUG 모드 운영 환경에서 비활성화
- 로그에 비밀번호, 카드번호 등 마스킹
- 보안 이벤트(로그인 실패, 권한 거부 등) 별도 기록

---

## 슬라이드 140: 12차시 시작 (공급망)

**강의 스크립트:**

12차시, 마지막 차시입니다. "종속성 및 패키지 공급망 보안"입니다.

SolarWinds 사례처럼 공급망 공격이 급증하고 있습니다. pip 패키지에도 악성코드가 심어질 수 있습니다. 타이포스쿼팅 공격으로 비슷한 이름의 악성 패키지가 등록되기도 합니다.

---

## 슬라이드 141-149: 12차시 공급망 및 마무리

**강의 스크립트:**

(각 슬라이드별 설명 - Safety, pip-audit, Bandit, 버전 고정, CI/CD 통합, SBOM, 과정 요약 등)

핵심은:
- 의존성 버전 고정 (requirements.txt에 ==)
- 정기적 취약점 스캔 (Safety, pip-audit)
- 정적 코드 분석 (Bandit)
- CI/CD 파이프라인에 보안 검사 통합
- SBOM 생성 (규제 요구사항)

마지막 슬라이드에서는 전체 과정을 요약합니다:
- 시큐어코딩 7대 원칙
- 보안 도구 요약 (Bandit, Safety, pip-audit)
- 실습 환경 명령어

감사 인사와 함께 참고 자료 링크를 제공합니다.

---

## 부록: 강의 진행 팁

### 시간 관리
- 각 차시 시작 전 학습 목표를 명확히 제시
- 이론 설명은 15-20분 내로 압축
- 실습 시간 확보가 중요 (최소 15-20분)
- 질문은 정리 시간에 모아서 처리

### 학습자 참여 유도
- 코드 예제에서 "무엇이 위험한지" 먼저 질문
- 실습 중 순회하며 개별 피드백
- 확인 문제는 학습자가 직접 답하도록 유도

### 실습 환경 문제 대응
- Docker 환경 문제 시 대안 준비 (로컬 Python 환경)
- 네트워크 문제 시 오프라인 리소스 활용
- 공통 오류는 화면 공유로 해결

### 추가 자료 안내
- OWASP 웹사이트
- Python Security 문서
- 각 보안 도구 공식 문서

---

*본 스크립트는 강사의 경험과 학습자 반응에 따라 조정하여 사용하시기 바랍니다.*
